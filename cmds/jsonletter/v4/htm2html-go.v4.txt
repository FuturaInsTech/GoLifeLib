// htm2html.exe program code version 4
// Usage: htm2html <base_filename> // without extension of .htm
// In v3 Added header and footer file processing
// In v3 saved Font Definitions in style tag and dropped HTML comment lines
// In v3 Synchoronized all lang tags to body lang value
// In v4 Adjusted clean up routines and process TOC html tags to align with word formatting correctly

package main

import (
	"fmt"
	"html"
	"io"
	"os"
	"regexp"
	"strconv"
	"strings"
)

// Function to check if required files exist
func checkInputHTMFilesExist(arg string) {

	jFile := arg + ".htm"
	jhFile := arg + "-h.htm"
	jfFile := arg + "-f.htm"

	// Check if HTM files Exists
	if _, err := os.Stat(jFile); os.IsNotExist(err) {
		fmt.Printf("Error: File '%s' does not exist.\n", jFile)
		os.Exit(1)
	}
	if _, err := os.Stat(jhFile); os.IsNotExist(err) {
		fmt.Printf("Error: File '%s' does not exist.\n", jhFile)
		os.Exit(1)
	}
	if _, err := os.Stat(jfFile); os.IsNotExist(err) {
		fmt.Printf("Error: File '%s' does not exist.\n", jfFile)
		os.Exit(1)
	}
	// Continue processing...
	fmt.Printf("All files '%s', '%s' and '%s' exists. Start Processing...\n", jFile, jhFile, jfFile)
}

// Helper Function to safely escapes text for HTML output
func htmlEscape(s string) string {
	return html.EscapeString(s)
}

// Processes TOC HTML in htm file and builds a PDF-friendly TOC
// that fills leaders with actual dot characters computed at render time.
func BuildTOCTable(htmlContent string) string {
	// Regex patterns
	blockRe := regexp.MustCompile(`(?is)(?:<p[^>]*class\s*=\s*["']?MsoToc\d+["']?[^>]*>.*?</p>\s*)+`)
	paraRe := regexp.MustCompile(`(?is)<p[^>]*class\s*=\s*["']?MsoToc\d+["']?[^>]*>(.*?)</p>`)
	tagStrip := regexp.MustCompile(`(?is)<[^>]+>`)
	lastDigits := regexp.MustCompile(`([0-9]+)\s*$`)
	indexFromMsoList := regexp.MustCompile(`(?is)<span[^>]*mso-list:Ignore[^>]*>\s*([^<\s]+)\s*</span>`)
	indexHTMLRe := regexp.MustCompile(`(?is)^\s*(?:<[^>]+>\s*)*([0-9]+(?:\.[0-9]+)*)[.)]?\s*`)

	// Cleanup function to remove Word spans, links, dotted lines, extra spaces
	cleanTOCTitle := func(innerHTML string) string {
		// Remove mso-tab-count spans (dotted lines)
		reTab := regexp.MustCompile(`(?is)<span[^>]*mso-tab-count[^>]*>.*?</span>`)
		innerHTML = reTab.ReplaceAllString(innerHTML, "")

		// Remove all <a> tags
		reA := regexp.MustCompile(`(?is)</?a[^>]*>`)
		innerHTML = reA.ReplaceAllString(innerHTML, "")

		// Remove all other Word-specific spans, styles, etc.
		reSpan := regexp.MustCompile(`(?is)</?span[^>]*>`)
		innerHTML = reSpan.ReplaceAllString(innerHTML, "")

		// Remove all Word XML tags like <w:*>
		reWordXML := regexp.MustCompile(`(?is)<w:[^>]+>.*?</w:[^>]+>`)
		innerHTML = reWordXML.ReplaceAllString(innerHTML, "")

		// Remove conditional comments like <![endif]> or <![if !supportLists]>
		reCond := regexp.MustCompile(`(?is)<!\[.*?\]>`)
		innerHTML = reCond.ReplaceAllString(innerHTML, "")

		// Replace non-breaking spaces and trim
		innerHTML = strings.ReplaceAll(innerHTML, "\u00A0", " ")
		innerHTML = strings.ReplaceAll(innerHTML, "&nbsp;", " ")
		innerHTML = strings.TrimSpace(innerHTML)

		// Collapse multiple whitespace or control characters into a single space
		innerHTML = regexp.MustCompile(`[^\S\r\n]+`).ReplaceAllString(innerHTML, " ")

		// Collapse multiple spaces
		innerHTML = regexp.MustCompile(`\s+`).ReplaceAllString(innerHTML, " ")

		// Trim leading/trailing spaces
		innerHTML = strings.TrimSpace(innerHTML)

		return innerHTML
	}

	locs := blockRe.FindAllStringIndex(htmlContent, -1)
	if locs == nil {
		return htmlContent
	}

	pageStripRe := regexp.MustCompile(`(?is)(?:\s|&nbsp;|<[^>]+>)*(?:[0-9](?:\s|&nbsp;|<[^>]+>)*)+$`)
	tabRe := regexp.MustCompile(`(?is)<span[^>]*mso-tab-count[^>]*>.*?</span>`)
	listIgnoreRe := indexFromMsoList

	// Process blocks from end->start
	for i := len(locs) - 1; i >= 0; i-- {
		start, end := locs[i][0], locs[i][1]
		blockHTML := htmlContent[start:end]

		paras := paraRe.FindAllStringSubmatch(blockHTML, -1)
		if len(paras) == 0 {
			continue
		}

		// Split paragraphs into segments by "[PageBrk]"
		var segments [][]string
		current := []string{}
		for _, pm := range paras {
			inner := strings.TrimSpace(pm[1])
			if strings.Contains(inner, "[PageBrk]") {
				if len(current) > 0 {
					segments = append(segments, current)
					current = []string{}
				}
				continue
			}
			current = append(current, inner)
		}
		if len(current) > 0 {
			segments = append(segments, current)
		}

		// Build table from paragraph slice
		buildTable := func(rows []string) string {
			var trs []string
			for _, innerHTML := range rows {
				plain := tagStrip.ReplaceAllString(innerHTML, "")
				plain = strings.ReplaceAll(plain, "\u00A0", " ")
				plain = strings.ReplaceAll(plain, "&nbsp;", " ")
				plain = strings.TrimSpace(plain)

				md := lastDigits.FindStringSubmatch(plain)
				if len(md) != 2 {
					continue
				}
				pageNum := md[1]

				if len(pageNum) == 1 {
					pageNum = fmt.Sprintf("%02s", pageNum)
				}

				titleHTML := pageStripRe.ReplaceAllString(innerHTML, "")
				titleHTML = strings.TrimSpace(titleHTML)
				titleHTML = tabRe.ReplaceAllString(titleHTML, "")
				titleHTML = listIgnoreRe.ReplaceAllString(titleHTML, "")

				indexText := ""
				if m := indexFromMsoList.FindStringSubmatch(innerHTML); len(m) == 2 {
					indexText = strings.TrimSpace(m[1])
				} else if m := indexHTMLRe.FindStringSubmatch(innerHTML); len(m) == 2 {
					indexText = strings.TrimSpace(m[1])
				} else {
					if m := regexp.MustCompile(`^([0-9]+(?:\.[0-9]+)*)[.)]?\s+`).FindStringSubmatch(plain); len(m) == 2 {
						indexText = m[1]
					}
				}

				if indexText != "" {
					esc := regexp.QuoteMeta(indexText)
					removeIndexRe := regexp.MustCompile(`(?is)^(?:<[^>]+>\s*)*` + esc + `(?:[.)]\s*)?(?:\s*</[^>]+>)*`)
					titleHTML = removeIndexRe.ReplaceAllString(titleHTML, "")
					titleHTML = strings.TrimSpace(titleHTML)
				}

				if titleHTML == "" {
					descPlain := lastDigits.ReplaceAllString(plain, "")
					descPlain = strings.TrimSpace(descPlain)
					titleHTML = descPlain
				}

				titleHTML = regexp.MustCompile("(?is)^[\\s\\.\u00B7\\-]+").ReplaceAllString(titleHTML, "")
				titleHTML = strings.TrimSpace(titleHTML)

				// Clean Word-specific formatting
				titleHTML = cleanTOCTitle(titleHTML)

				// Prevent line breaks in TOC titles
				reSpaces := regexp.MustCompile(`\s+`)
				titleHTML = reSpaces.ReplaceAllString(titleHTML, "&nbsp;")

				// Row: index | title | page
				tr := fmt.Sprintf(`<tr>
  <td class="toc-index">%s</td>
  <td class="toc-title">%s</td>
  <td class="toc-page">%s</td>
</tr>`, htmlEscape(indexText), htmlEscape(titleHTML), htmlEscape(pageNum))

				trs = append(trs, tr)
			}
			if len(trs) == 0 {
				return ""
			}
			return `<table class="toc-table" role="presentation">
  <colgroup>
    <col style="width:6em">
    <col>
    <col style="width:6em">
  </colgroup>
  <tbody>` + strings.Join(trs, "\n") + `</tbody></table>`
		}

		var builtParts []string
		for si, seg := range segments {
			tbl := buildTable(seg)
			if tbl != "" {
				builtParts = append(builtParts, tbl)
			}
			if si < len(segments)-1 {
				builtParts = append(builtParts, `<div style="page-break-before:always;"></div>`)
			}
		}
		replacement := strings.Join(builtParts, "\n")
		htmlContent = htmlContent[:start] + replacement + htmlContent[end:]
	}

	// Inject CSS only (simple table, no dotted lines)
	cssOnly := `<style id="tocfix-style">
.toc-table { width:100%; border-collapse:collapse; font-family:inherit; font-size:inherit; table-layout:fixed;}
.toc-table td { padding:0; margin:0; vertical-align:middle; }
.toc-index { white-space:nowrap; padding-right:0.6em; text-align:left; }
.toc-title { white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
.toc-page { white-space:nowrap; text-align:right; width:6em;}
[role="presentation"] { border-collapse:collapse; }
</style>`

	lower := strings.ToLower(htmlContent)
	if !strings.Contains(lower, "tocfix-style") {
		if idx := strings.Index(lower, "</head>"); idx != -1 {
			htmlContent = htmlContent[:idx] + cssOnly + htmlContent[idx:]
		} else {
			htmlContent = cssOnly + htmlContent
		}
	}

	return htmlContent
}

// Extract the right dotted tab stop value (in pt) from a TOC paragraph
func extractTabStop(line string) string {
	tabRe := regexp.MustCompile(`right dotted ([0-9.]+pt)`)
	if m := tabRe.FindStringSubmatch(line); len(m) > 1 {
		return m[1]
	}
	return "500pt" // fallback
}

// Convert pt â†’ px
func ptToPx(ptStr string) int {
	pt, err := strconv.ParseFloat(ptStr, 64)
	if err != nil {
		return 650 // safe fallback
	}
	return int(pt * 96.0 / 72.0) // 1pt = 96/72 px
}

// Finds TOC paragraphs in the full HTML and replace with aligned versions.
func ProcessTOCBlock(html string) string {
	// Find all TOC <p> lines (MsoToc class)
	pRe := regexp.MustCompile(`(?is)<p[^>]*class="?MsoToc\d+"?[^>]*>.*?</p>`)
	lines := pRe.FindAllString(html, -1)
	if len(lines) == 0 {
		return html // no TOC
	}

	// Extract the first tab stop (used for all lines)
	tabStop := extractTabStop(lines[0])
	pxStop := ptToPx(tabStop)

	// Rebuild aligned lines
	replacements := make(map[string]string)
	for _, line := range lines {
		newLine := cleanTOCLine(line, pxStop)
		replacements[line] = newLine
	}

	// Replace in original HTML
	result := html
	for old, new := range replacements {
		result = strings.ReplaceAll(result, old, new)
	}

	return result
}

// Clean and align a single TOC <p> line
func cleanTOCLine(line string, pxStop int) string {
	// Grab attributes
	attrRe := regexp.MustCompile(`(?is)^<p([^>]*)>.*</p>`)
	attr := ""
	if m := attrRe.FindStringSubmatch(line); len(m) > 1 {
		attr = m[1]
	}

	// Extract inner text
	innerRe := regexp.MustCompile(`(?is)^<p[^>]*>(.*)</p>`)
	inner := ""
	if m := innerRe.FindStringSubmatch(line); len(m) > 1 {
		inner = m[1]
	}

	// Extract page number
	pageRe := regexp.MustCompile(`(\d+)\s*$`)
	page := ""
	desc := inner
	if m := pageRe.FindStringSubmatch(inner); len(m) > 1 {
		page = m[1]
		desc = strings.TrimSpace(inner[:len(inner)-len(page)])
	}
	desc = strings.TrimRight(desc, ". \u00A0")

	// Rebuild with flexbox for perfect alignment
	return fmt.Sprintf(
		`<p%[1]s style="display:flex; justify-content:space-between; max-width:%[2]dpx;">
  <span>%[3]s</span>
  <span>%[4]s</span>
</p>`,
		attr, pxStop, desc, page,
	)
}

// Takes a multi-line HTML string and joins attributes into a single line.
func JoinHTMLAttributes(html string) string {
	// Preserve blank lines by temporarily marking them
	placeholder := "__BLANK_LINE__"
	compactHTML := strings.ReplaceAll(html, "\n\n", placeholder)

	// Remove all remaining single newlines (join lines)
	re := regexp.MustCompile(`\n+`)                     // Match one or more newlines
	compactHTML = re.ReplaceAllString(compactHTML, " ") // Replace newlines with space

	// Restore blank lines
	compactHTML = strings.ReplaceAll(compactHTML, placeholder, "\n\n")

	// Remove newlines and excessive whitespace
	compactHTML = regexp.MustCompile(`\s{2,}`).ReplaceAllString(compactHTML, " ") // Collapse multiple spaces

	// Trim any unnecessary spaces at the start or end
	return strings.TrimSpace(compactHTML)
}

func ExtractFontDefinitions(html string) (string, string) {
	commentRe := regexp.MustCompile(`(?s)<!--(.*?)-->`)
	matches := commentRe.FindAllStringSubmatch(html, -1)

	var styleBlock string

	for _, match := range matches {
		fullComment := match[0]
		commentBody := match[1]

		if styleBlock == "" && strings.Contains(strings.ToLower(commentBody), "font definitions") {
			cleaned := strings.TrimSpace(commentBody)
			styleBlock = "<style>\n" + cleaned + "\n</style>"
		}
		html = strings.Replace(html, fullComment, "", 1) // remove the comment
	}

	return html, styleBlock
}

func InsertStyleIntoHead(html string, styleBlock string) string {
	if styleBlock == "" {
		return html
	}
	headRe := regexp.MustCompile(`(?i)<head[^>]*>`)
	loc := headRe.FindStringIndex(html)

	if loc != nil {
		insertPos := loc[1] // after <head>
		html = html[:insertPos] + "\n" + styleBlock + "\n" + html[insertPos:]
	}
	return html
}

func isSingleColumnTable(table string) bool {
	// Find all rows
	reTr := regexp.MustCompile(`(?is)<tr[^>]*>.*?</tr>`)
	rows := reTr.FindAllString(table, -1)

	for _, row := range rows {
		// Count td tags in this row
		reTd := regexp.MustCompile(`(?is)<td[^>]*>`)
		tds := reTd.FindAllString(row, -1)
		if len(tds) != 1 {
			return false // More than 1 column in a row
		}
	}
	return true
}

// Removes <o:p> tags only outside of <table> blocks.
// - <o:p>\s*</o:p> â†’ removed
// - <o:p>&nbsp;</o:p> â†’ replaced with <br>
func CleanOutsideTables(input string) string {
	// Regex for full <table> blocks
	reTable := regexp.MustCompile(`(?is)<table[^>]*>.*?</table>`)

	// Regex for <o:p> cleanup
	reEmpty := regexp.MustCompile(`(?i)<o:p>\s*</o:p>`)
	reNbsp := regexp.MustCompile(`(?i)<o:p>\s*&nbsp;\s*</o:p>`)

	var result string
	lastIndex := 0

	// Find all table blocks with their positions
	matches := reTable.FindAllStringIndex(input, -1)

	for _, m := range matches {
		// Process the text before this table (outside part)
		nonTable := input[lastIndex:m[0]]
		nonTable = reEmpty.ReplaceAllString(nonTable, "")
		nonTable = reNbsp.ReplaceAllString(nonTable, "<br>")
		result += nonTable

		// Add the untouched table
		result += input[m[0]:m[1]]

		lastIndex = m[1]
	}

	// Process any trailing text after the last table
	nonTable := input[lastIndex:]
	nonTable = reEmpty.ReplaceAllString(nonTable, "")
	nonTable = reNbsp.ReplaceAllString(nonTable, "<br>")
	result += nonTable

	return result
}

// Clean <o:p></o:p> tags to manage blank lines
// Used in htm2html processing
func cleanOEmptyP(input string) string {
	// In <table>
	// When only one <td> is in a <tr>
	// a. remove the <p> tag if its empty
	// b. clean up with <br> if having nbsp.
	// When there are more than one <td> in a <tr>
	// a. remove the <p> tag for both empty and having nbsp.
	reTable := regexp.MustCompile(`(?is)<table[^>]*>.*?</table>`)
	// Building the modified HTML
	processed := reTable.ReplaceAllStringFunc(input, func(table string) string {
		if isSingleColumnTable(table) {
			// clean single-column tables as required
			reEmpty := regexp.MustCompile(`(?i)<o:p>\s*</o:p>`)
			renbsp := regexp.MustCompile(`(?i)<o:p>\s*&nbsp;\s*</o:p>`)
			table = reEmpty.ReplaceAllString(table, "")
			return renbsp.ReplaceAllString(table, "<br>")
		}

		// For multi-column tables â†’ remove empty <p>
		re := regexp.MustCompile(`(?is)<td[^>]*>.*?</td>|<tr[^>]*>.*?</tr>`)
		return re.ReplaceAllStringFunc(table, func(block string) string {
			pRe := regexp.MustCompile(`(?is)<p[^>]*>(\s|<b[^>]*>|</b>|<span[^>]*>|</span>|<o:p>|</o:p>|&nbsp;)*</p>`)
			return pRe.ReplaceAllString(block, "")
		})
	})

	// Clean <o:p></o:p> tags outside <table> tags
	final := CleanOutsideTables(processed)
	return final

}

// Extracts the `lang` attribute from <body> and replaces
// all :lang(...) and [lang="..."] or [lang='...'] [*-language:'...'] values in the input content
func syncAllLangtoBodyLang(content string) (string, error) {
	var langValue string

	// Step 1: Extract lang from <body> or fallback to <html>
	bodyLangRe := regexp.MustCompile(`(?i)<body[^>]*\blang=["']?([^"'>\s]+)["']?`)
	if matches := bodyLangRe.FindStringSubmatch(content); len(matches) >= 2 {
		langValue = matches[1]
	} else {
		htmlLangRe := regexp.MustCompile(`(?i)<html[^>]*\blang=["']?([^"'>\s]+)["']?`)
		if matches := htmlLangRe.FindStringSubmatch(content); len(matches) >= 2 {
			langValue = matches[1]
		}
	}

	if langValue == "" {
		return content, fmt.Errorf("no lang attribute found in <body> or <html>")
	}

	// Step 2: Replace :lang(...) selectors
	content = regexp.MustCompile(`:lang\(([^)]+)\)`).ReplaceAllString(content, fmt.Sprintf(`:lang(%s)`, langValue))

	// Step 3: Replace [lang="..."] or [lang='...'] attribute selectors
	content = regexp.MustCompile(`\[lang=['"][^'"]+['"]\]`).ReplaceAllString(content, fmt.Sprintf(`[lang="%s"]`, langValue))

	// Step 4: Replace all *-language:... in inline styles or CSS
	// Handles mso-fareast-language, bidi-language, ansi-language, etc.
	content = regexp.MustCompile(`(?i)([\w\-]+-language)\s*:\s*[a-z\-A-Z]+`).ReplaceAllString(content, fmt.Sprintf(`${1}:%s`, langValue))

	return content, nil
}

// Replace v:imagedata Tags with img tag
// Used in htm2html processing
func ReplaceImageDataTagWithImgTag(input string) string {
	// Regular expression to find <v:imagedata ... />
	re := regexp.MustCompile(`<v:imagedata([^>]*)\/?>`)
	// Replace matches with the content inside the tags
	return re.ReplaceAllString(input, `<img${1}/>`)
}

// Strip SpellE SpanTags removes Spelling Eror non-standard tags but keeps others.
// Used in htm2html processing
func StripSpellESpanTags(input string) string {
	// Regular expression to match <span> tags with class=SpellE
	re := regexp.MustCompile(`(?i)<span[^>]*class\s*=\s*["']?SpellE["']?[^>]*>(.*?)</span>`)
	// Replace matches with the content inside the tags
	return re.ReplaceAllString(input, `$1`)
}

// Strip GramE SpanTags removes Grammer Eror non-standard tags but keeps others.
// Used in htm2html processing
func StripGramESpanTags(input string) string {
	// Regular expression to match <span> tags with class=GramE
	re := regexp.MustCompile(`(?i)<span[^>]*class\s*=\s*["']?GramE["']?[^>]*>(.*?)</span>`)
	// Replace matches with the content inside the tags
	return re.ReplaceAllString(input, `$1`)
}

func processHTMLFile(inputFilePath, outputFilePath string) {
	// Open the input file
	inputFile, err := os.Open(inputFilePath)
	if err != nil {
		fmt.Printf("Error opening input file: %v\n", err)
		return
	}
	defer inputFile.Close()

	// Read the input file content
	content, err := io.ReadAll(inputFile)
	if err != nil {
		fmt.Printf("Error reading input file: %v\n", err)
		return
	}

	//tocCleanedContent := ProcessTOCBlock(string(content))
	tocCleanedContent := BuildTOCTable(string(content))

	// JoinHTMLAttributes takes a multi-line HTML string and joins attributes into a single line
	joinedContent := JoinHTMLAttributes(tocCleanedContent)

	// Correct HTM file tags for HTML standards.....
	// 1. Save the Font Defintions from HTML Comments into style tag
	// 2. Clean empty o:p tags and remove HTML comment lines
	// 3. Synchronize all lang tages to body lang values
	// 4. Replacing v:imagedata tags with img tag & <o:p>&nbsp</o:p> with <br> tag
	// 5. Removing Spelling & Grammer Error nonstandard tags
	temp1Content, styleblock := ExtractFontDefinitions(string(joinedContent))
	tempContent := InsertStyleIntoHead(temp1Content, styleblock)

	temp1Content = cleanOEmptyP(string(tempContent))
	tempContent, _ = syncAllLangtoBodyLang(string(temp1Content))

	temp1Content = ReplaceImageDataTagWithImgTag(string(tempContent))
	tempContent = StripSpellESpanTags(string(temp1Content))

	processedContent := StripGramESpanTags(string(tempContent))
	// End of Corrections

	// Write the processed content to the output file
	err = os.WriteFile(outputFilePath, []byte(processedContent), 0644)
	if err != nil {
		fmt.Printf("Error writing to output file: %v\n", err)
		return
	}

	fmt.Printf("Processed HTML content written to %s\n", outputFilePath)
}

func main() {
	var inputFile string
	var iheaderFile string
	var ifooterFile string

	var outputFile string
	var oheaderFile string
	var ofooterFile string

	var iFile string

	// Check the number of command-line arguments
	if len(os.Args) > 2 {
		fmt.Println("Error: Too many arguments provided. Please provide <basefilename> ...")
		fmt.Println("Usage: cmd <basefilename> ...")
	} else if len(os.Args) == 2 {
		iFile = os.Args[1]
	} else {
		fmt.Printf("Error: No arguments provided.\n")
		os.Exit(1)
	}

	inputFile = iFile + ".htm"
	iheaderFile = iFile + "-h.htm"
	ifooterFile = iFile + "-f.htm"

	outputFile = iFile + ".html"
	oheaderFile = iFile + "-h.html"
	ofooterFile = iFile + "-f.html"

	// Check if the required files exist
	checkInputHTMFilesExist(iFile)
	fmt.Println("  In Progress...")

	htm2html(inputFile, outputFile)
	htm2html(iheaderFile, oheaderFile)
	htm2html(ifooterFile, ofooterFile)
}

func htm2html(iFile string, oFile string) {
	// Input and output file paths
	inputFilePath := iFile
	outputFilePath := oFile

	// Process the file
	processHTMLFile(inputFilePath, outputFilePath)

	fmt.Println("HTML generated successfully: ", oFile)
}
