// Program Name: pdf2xl.exe
// Description : Save the contents of an input .pdf File as an Output .xlsx File with Single Sheet.
package main

import (
	"fmt"
	"log"
	"os"
	"sort"

	"github.com/ledongthuc/pdf"
	"github.com/xuri/excelize/v2"
)

type textFragment struct {
	x float64
	y float64
	s string
}

var pdffile string
var outfile string

func main() {
	// Check the number of command-line arguments
	if len(os.Args) > 3 {
		fmt.Println("Error: Too many arguments provided..")
		fmt.Println("Usage: cmd <pdffile> [<outfile>]")
	} else if len(os.Args) == 3 {
		pdffile = os.Args[1] + ".pdf"
		outfile = os.Args[2] + ".xlsx"
	} else if len(os.Args) == 2 {
		pdffile = os.Args[1] + ".pdf"
		outfile = os.Args[1] + ".xlsx"
	} else {
		fmt.Printf("Error: No arguments provided.\n")
		fmt.Println("Usage: cmd <pdffile> [<outfile>]")
		os.Exit(1)
	}

	inputPDF := pdffile
	outputExcel := outfile

	// Open PDF
	f, r, err := pdf.Open(inputPDF)
	if err != nil {
		log.Fatalf("Failed to open PDF: %v", err)
	}
	defer f.Close()

	// Create Excel file
	excel := excelize.NewFile()
	sheet := "Sheet1"
	excel.SetSheetName("Sheet1", sheet)

	rowIndex := 1
	const gapThreshold = 10.0 // points, to detect cell breaks

	// Iterate through PDF pages
	for pageIndex := 1; pageIndex <= r.NumPage(); pageIndex++ {
		page := r.Page(pageIndex)
		if page.V.IsNull() {
			continue
		}

		content := page.Content()

		// Group text fragments by line (Y coordinate)
		lines := map[float64][]textFragment{}
		for _, txt := range content.Text {
			lines[txt.Y] = append(lines[txt.Y], textFragment{txt.X, txt.Y, txt.S})
		}

		// Sort lines top to bottom
		var ys []float64
		for y := range lines {
			ys = append(ys, y)
		}
		sort.Sort(sort.Reverse(sort.Float64Slice(ys)))

		// Process each line
		for _, y := range ys {
			fragments := lines[y]

			// Sort fragments left to right
			sort.Slice(fragments, func(i, j int) bool { return fragments[i].x < fragments[j].x })

			colIndex := 1
			currentCell := ""

			for i, frag := range fragments {
				// Append text to current cell
				currentCell += frag.s

				// Look ahead to see if there is a large gap (cell break)
				if i < len(fragments)-1 {
					next := fragments[i+1]
					gap := next.x - frag.x - textWidthEstimate(frag.s)
					if gap > gapThreshold {
						// Write current cell to Excel
						cellName, _ := excelize.ColumnNumberToName(colIndex)
						excel.SetCellValue(sheet, fmt.Sprintf("%s%d", cellName, rowIndex), currentCell)

						// Move to next cell
						colIndex++
						currentCell = ""
					}
				}
			}

			// Write last cell in the row
			if currentCell != "" {
				cellName, _ := excelize.ColumnNumberToName(colIndex)
				excel.SetCellValue(sheet, fmt.Sprintf("%s%d", cellName, rowIndex), currentCell)
			}

			rowIndex++
		}
	}

	// Save Excel file
	if err := excel.SaveAs(outputExcel); err != nil {
		log.Fatalf("Failed to save Excel file: %v", err)
	}

	fmt.Println("Table data saved to:", outputExcel)
}

// Estimate text width (basic fixed-width assumption)
func textWidthEstimate(s string) float64 {
	return float64(len(s)) * 5.0 // 5 points per char (adjust if needed)
}
