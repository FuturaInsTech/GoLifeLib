// Using Web HTML file generate GOHTML file

package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"unicode"

	"golang.org/x/net/html"
)

func main() {

	var inputFile string
	var outputFile string
	// os.Args contains the command-line arguments.
	// os.Args[0] is the program name.
	// os.Args[1:] are the actual arguments.
	args := os.Args[1:]

	if len(args) == 0 {
		fmt.Println("Error: No arguments provided.")
		fmt.Println("Usage: ", os.Args[0], "<inputFile> <outputFile>")
		os.Exit(1) // Exit with a non-zero status to indicate an error
	}

	// Check if  2 out of 4 arguments are provided
	if len(args) == 1 {

		fmt.Println("  Args:", os.Args)
		fmt.Println("  In Progress...")
		inputFile = os.Args[1]
		outputFile = "outfile.gohtml"
		fmt.Println("Default output file is outfile.gohtml")
	}

	// Check if  2 out of 4 arguments are provided
	if len(args) == 2 {
		fmt.Println("  Args:", os.Args)
		fmt.Println("  In Progress...")
		inputFile = os.Args[1]
		outputFile = os.Args[2]
	}

	html2gohtml(inputFile, outputFile)
}

func html2gohtml(inputFile string, outputFile string) {
	// Define the project root directory
	projectRoot := "./" // Adjust this if the script isn't at the project root
	staticFolder := filepath.Join(projectRoot, "static")

	// Specify the html file
	htmlFile := inputFile // Replace with your actual file name
	fileNameWithoutExt := strings.TrimSuffix(htmlFile, filepath.Ext(htmlFile))

	// Define source and destination folders
	cpysrcFolder := filepath.Join(projectRoot, fileNameWithoutExt+"_files")
	cpydestFolder := filepath.Join(staticFolder, fileNameWithoutExt)
	imgdestFolder := "{{.Img}}"

	// Ensure the new folder exists
	err := os.MkdirAll(cpydestFolder, os.ModePerm)
	if err != nil {
		fmt.Println("Error creating new folder:", err)
		return
	}

	// Read the HTML file
	htmlContent, err := os.ReadFile(inputFile)
	if err != nil {
		fmt.Printf("Error reading HTML file: %v\n", err)
		return
	}

	// Parse the HTML content
	doc, err := html.Parse(bytes.NewReader(htmlContent))
	if err != nil {
		fmt.Printf("Error parsing HTML file: %v\n", err)
		return
	}

	// Process the HTML to update image paths
	err = updateImagePaths(doc, cpysrcFolder, cpydestFolder, imgdestFolder)
	if err != nil {
		fmt.Println("Error updating image paths:", err)
		return
	}

	var Tcolct int = 0
	// Convert the parsed HTML into GoHTML format
	var processedHTML bytes.Buffer
	processNode(doc, &processedHTML, 0, Tcolct)

	// Write the GoHTML content to the output file
	err = os.WriteFile(outputFile, processedHTML.Bytes(), 0644)
	if err != nil {
		fmt.Printf("Error writing GoHTML file: %v\n", err)
		return
	}

	fmt.Printf("GoHTML file created successfully at: %s\n", outputFile)
} // MAIN ENDS HERE

// These variables are to manage the range line and range data to write at correct place after
// counting the number of tr tags, to process merged column headers and multi line headers of
// homogeneous table where json data determine the number of row to get printed in gohtml

var Rtag string = ""
var Rcolct int = 0

var trcount int = 0
var tabletrct int = 0

var Rrangeline string = ""
var Rrangedata string = ""

// processNode processes an HTML node and writes GoHTML output
func processNode(n *html.Node, buffer *bytes.Buffer, indentLevel int, Tcolct int) {
	// Calc the number of columns first if its a table node
	if n.Data == "table" {
		Tcolct, trcount = CountRInTable(n)
		if Tcolct > 0 {
			var t *html.Node
			t = n
			Rstring := findRStringInTable(t)
			if Rstring != "" {
				Rrangeline = transformToProtectedGoHTML(Rstring, Rcolct)
			}
		}
	}

	indent := strings.Repeat("  ", indentLevel)
	text := strings.TrimSpace(n.Data)
	if strings.Contains(text, "<R>") {
		Rtag = "B"
	} else if strings.Contains(text, "</R>") {
		Rtag = "E"
	} else {
		Rtag = ""
	}

	switch n.Type {

	case html.TextNode: // 1
		if Rtag == "B" {
			// Alter placeholders for GoHTML range construct in text content
			Rrangedata = transformToProtectedGoHTML(text, Rcolct)
			buffer.WriteString(fmt.Sprintf("%s", Rrangedata))
			if Rcolct <= Tcolct {
				Rcolct = Rcolct + 1
			}
		} else {
			// Replace placeholders and escape double quotes in text content
			processedText := escapeAttribute(processPlaceholders(text))
			if processedText != "" {
				buffer.WriteString(fmt.Sprintf("%s%s\n", indent, processedText))
			}
		}
	case html.DocumentNode: // 2
		// Process children only
		for c := n.FirstChild; c != nil; c = c.NextSibling {
			processNode(c, buffer, indentLevel, Tcolct)
		}

	case html.ElementNode: // 3
		// check tr after table and increment only if it a R table
		if n.Data == "tr" && Rrangeline != "" {
			if tabletrct == (trcount - 1) {
				buffer.WriteString(fmt.Sprintf("%s", Rrangeline))
				Rcolct = Rcolct + 1
			} else {
				tabletrct = tabletrct + 1
			}
		}

		// Handle input and textarea elements specifically
		if n.Data == "input" || n.Data == "textarea" || n.Data == "textbox" {
			// Handle value attribute as placeholder
			for _, attr := range n.Attr {
				if attr.Key == "value" {
					// Process the value attribute as a GoHTML placeholder
					attr.Val = escapeAttribute(processPlaceholders(attr.Val))
				}
			}
		}

		// Write opening tag with attributes
		buffer.WriteString(fmt.Sprintf("%s<%s", indent, n.Data))
		for _, attr := range n.Attr {
			// Properly escape attribute values, replacing double quotes with &quot;
			if attr.Key != "value" {
				buffer.WriteString(fmt.Sprintf(` %s="%s"`, attr.Key, escapeAttribute(attr.Val)))
			} else {
				// Special handling for value attributes
				buffer.WriteString(fmt.Sprintf(` %s="%s"`, attr.Key, escapeAttribute(attr.Val)))
			}
		}
		buffer.WriteString(">\n")

		// Process children recursively
		for c := n.FirstChild; c != nil; c = c.NextSibling {
			if n.Data == "tbody" && Rrangeline != "" && Rcolct > 0 && Rcolct > Tcolct {
				buffer.WriteString(fmt.Sprintf("\n {{ end }} \n"))
				Rrangeline = ""
				Rcolct = 0
				Tcolct = 0
				Rtag = ""
				tabletrct = 0
				trcount = 0
			}
			processNode(c, buffer, indentLevel+1, Tcolct)
		}

		// Write closing tag
		buffer.WriteString(fmt.Sprintf("%s</%s>\n", indent, n.Data))

	case html.CommentNode: // 4
		// Preserve comments if needed
		buffer.WriteString(fmt.Sprintf("%s<!-- %s -->\n", indent, n.Data))
	default:
		// Log unsupported node types for debugging
		fmt.Printf("Ignoring node type: %v\n", n.Type)
	}
} // PROCESSNODE ENDS HERE

// process all <FieldName> and <FieldName D2> and process to GOHTML format {{ formatNumber ($.FieldName) 2 }}
func processPlaceholders(input string) string {
	// Clean the string to remove newlines and whitespaces within angled brackets
	input = cleanString(input)
	// Regex to match variables in the format <content> where content can have one or more parts
	re := regexp.MustCompile(`<([^<>]+)>`)
	return re.ReplaceAllStringFunc(input, func(match string) string {
		// Extract content inside the angle brackets
		trimmedContent := match[1 : len(match)-1] // Strip the angle brackets

		// Split the content into parts based on whitespace
		parts := strings.Fields(trimmedContent)

		if len(parts) == 1 {
			return "{{ $." + strings.TrimSpace(parts[0]) + " }} "
		} else if (len(parts)) == 2 {
			part1 := parts[1]
			if isAlphaDigit(part1) {
				return "{{ formatNumber $." + strings.TrimSpace(parts[0]) + " " + `"` + part1 + `"` + " }} "
			} else {
				return "{{ $." + strings.TrimSpace(parts[0]) + "-CHECKFORMAT-" + part1 + " }} "
			}
		} else {
			return input

		}
	})
}

// escapeAttribute replaces double quotes with &quot; in attribute values and text content
func escapeAttribute(value string) string {
	// Replace double quotes with &quot if not formatNumber;
	if !strings.Contains(value, "formatNumber") {
		return strings.ReplaceAll(value, `"`, `&quot;`)
	}
	return value
}

// updateImagePaths processes the HTML nodes to update image paths
func updateImagePaths(n *html.Node, cpysrcFolder, cpydestFolder, imgdestFolder string) error {
	if n.Type == html.ElementNode && n.Data == "img" {
		for i, attr := range n.Attr {
			if attr.Key == "src" {
				oldSrc := attr.Val
				oldPath := filepath.Join(cpysrcFolder, filepath.Base(oldSrc))
				newPath := filepath.Join(cpydestFolder, filepath.Base(oldSrc))

				// Copy the image file to the new folder
				err := copyFile(oldPath, newPath)
				if err != nil {
					return fmt.Errorf("error copying file %s to %s: %v", oldPath, newPath, err)
				}

				// Update the src attribute with {{.Img}} variable path
				n.Attr[i].Val = filepath.Join(imgdestFolder, filepath.Base(oldSrc))
			}
		}
	}

	// Recursively process child nodes
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		err := updateImagePaths(c, cpysrcFolder, cpydestFolder, imgdestFolder)
		if err != nil {
			return err
		}
	}

	return nil
}

// copyFile copies a file from src to dst
func copyFile(src, dst string) error {
	srcFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer srcFile.Close()

	dstFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer dstFile.Close()

	_, err = io.Copy(dstFile, srcFile)
	return err
}

// Function to transform <R>...</R> blocks to Go template syntax while preserving style tags
func transformToProtectedGoHTML(input string, Rcolct int) string {
	// Clean the string to remove newlines and whitespaces within angled brackets
	input = cleanString(input)

	// Regex to match <R> ... </R> blocks
	re := regexp.MustCompile(`(?s)<R>(.*?)</R>`)
	matches := re.FindAllStringSubmatch(input, -1)

	if len(matches) == 0 {
		fmt.Println("No <R>.<>..</R> tags found")
		return input
	}

	for _, match := range matches {
		content := match[1]

		// Regex to match variables in the format <content> where content can have one or more parts
		re := regexp.MustCompile(`<([^<>]+)>`)
		trimmedContent := re.ReplaceAllStringFunc(content, func(match string) string {
			// Extract content inside the angle brackets
			trimmedContent := match[1 : len(match)-1] // Strip the angle brackets
			return trimmedContent
		})
		// Split the content into parts based on whitespace
		parts := strings.Fields(trimmedContent)

		// Replace original <R> ... </R> with transformed content wrapped in {{range ... end}}
		var rangeBlock string
		if Rcolct == 0 {
			// Handle single or multiple parts (customize the processing here)
			rangeBlock = "{{range $index, $element := ." + strings.TrimSpace(parts[0]) + "}} \n "
		} else if Rcolct == 1 {
			rangeBlock = "{{$element}}"
		} else {
			if len(parts) == 1 {
				rangeBlock = "{{ (index $." + strings.TrimSpace(parts[0]) + " $index) " + " }} "
			} else if (len(parts)) == 2 {
				part1 := parts[1]
				if isAlphaDigit(part1) {
					rangeBlock = "{{ formatNumber (index $." + strings.TrimSpace(parts[0]) + " $index) " + `"` + part1 + `"` + " }} "
				} else {
					rangeBlock = "{{ $." + parts[0] + "CHECKFORMAT-" + part1 + " }} "
				}
			} else {
				rangeBlock = "{{ $." + "CHECKFIELD-" + parts[0] + " }} "
			}
		}
		//input = strings.Replace(input, match, rangeBlock, 1)
		input = rangeBlock
		return input
	}
	return ""
}

// CountRInTable takes a table node and counts the number of <R> elements in it.
func CountRInTable(table *html.Node) (int, int) {
	if table == nil || table.Type != html.ElementNode || table.Data != "table" {
		return 0, 0
	}

	Rcount := 0
	trcount := 0
	// Traverse all child nodes of the table to find <R> elements
	var traverse func(node *html.Node)
	traverse = func(node *html.Node) {
		if node.Type == html.ElementNode && strings.Contains(node.Data, "tr") {
			trcount++
		}
		if node.Type == html.TextNode && strings.Contains(node.Data, "<R>") {
			Rcount++
		}
		for c := node.FirstChild; c != nil; c = c.NextSibling {
			traverse(c)
		}
	}

	// Start traversal from the table node
	traverse(table)
	return Rcount, trcount
}

// Helper to find the parent node with a specific tag
func findParent(n *html.Node, tagName string) *html.Node {
	for p := n.Parent; p != nil; p = p.Parent {
		if p.Type == html.ElementNode && p.Data == tagName {
			return p
		}
	}
	return nil
}

// Function to find the first <R> starting string in a table
func findRStringInTable(tableNode *html.Node) string {
	var result string

	// Traverse function to search within the table node
	var traverse func(*html.Node)
	traverse = func(n *html.Node) {
		if n == nil {
			return
		}

		// Check if the node contains a text node starting with <R>
		if n.Type == html.TextNode {
			text := strings.TrimSpace(n.Data)
			if strings.HasPrefix(text, "<R>") {
				result = text
				return
			}
		}

		// Traverse children if no result found
		for c := n.FirstChild; c != nil && result == ""; c = c.NextSibling {
			traverse(c)
		}
	}

	// Start traversing the table node
	traverse(tableNode)

	return result
}

// clean the contents in the angled brackets for processing
func cleanString(input string) string {
	// Remove multiple newlines and replace with a single newline
	re := regexp.MustCompile(`\n+`)
	normalized := re.ReplaceAllString(input, "")

	// Replace "< " with "<" and " >" with ">"
	normalized = strings.ReplaceAll(normalized, "< ", "<")
	normalized = strings.ReplaceAll(normalized, " >", ">")

	return normalized
}

func isAlphaDigit(s string) bool {
	// Check if the string length is 2
	if len(s) != 2 {
		return false
	}
	// Check if the first character is alphabetic
	if !unicode.IsLetter(rune(s[0])) {
		return false
	}
	// Check if the second character is a digit
	if !unicode.IsDigit(rune(s[1])) {
		return false
	}
	return true
}
