// To test GOHTML template with JSON Data to create a merged html file

package main

import (
	"encoding/json"
	"fmt"
	"html/template"
	"log"
	"os"
	"strconv"
	"strings"
)

// Used in testgohtmljson processing
func formatInteger(famt string, ctype byte) string {
	// Handle the Indian and Western numbering formats
	n := len(famt)
	if n <= 3 {
		// No formatting needed for numbers with 3 or fewer digits
		return famt
	}

	// Format the first three digits (thousands)
	result := famt[n-3:]

	if ctype == 'a' || ctype == 'A' {
		// Format the remaining digits in groups of two (lakhs, crores, etc.)
		for i := n - 3; i > 0; i -= 2 {
			start := i - 2
			if start < 0 {
				start = 0
			}
			result = famt[start:i] + "," + result
		}
	}
	if ctype == 'c' || ctype == 'C' {
		// Format the remaining digits in groups of three (millions, billions, etc.)
		for i := n - 3; i > 0; i -= 3 {
			start := i - 3
			if start < 0 {
				start = 0
			}
			result = famt[start:i] + "," + result
		}
	}

	// Return the formatted integer
	return result
}

// Used in testgohtmljson processing
func formatDecimal(famt string, ctype byte) string {
	decimalpart := ""
	decimallen, _ := strconv.Atoi(string(ctype))
	//damt, _ := strconv.Atoi(string(famt))
	var decimalFloat float64 = 0
	if decimallen == 0 {
		decimalFloat, _ = strconv.ParseFloat("0."+"0", 64)
	} else {
		decimalFloat, _ = strconv.ParseFloat("0."+string(famt), 64)
	}
	if decimallen == 0 {
		return decimalpart
	} else {
		formatString := fmt.Sprintf("%%.%df", decimallen) // Generate format string
		decimalpart = fmt.Sprintf(formatString, decimalFloat)
		decimalpart = decimalpart[1:] // Remove the leading "0"
		return decimalpart
	}
}

// Used in testgohtmljson processing
func formatNumber(value interface{}, fds string) string {
	integralpart := ""
	decimalpart := ""
	famt := ""
	famount := ""
	decimallen, _ := strconv.Atoi(string(fds[1]))
	if _, ok := value.(float64); ok {
		famt = strconv.FormatFloat(value.(float64), 'f', decimallen, 64) // Format float64 with d decimal places
	}
	if _, ok := value.(int); ok {
		famt = strconv.FormatFloat(float64(value.(int)), 'f', decimallen, 64) // Format float64 with d decimal places
	}
	if _, ok := value.(string); ok {
		famt = value.(string)
	}
	parts := strings.Split(famt, ".")
	if fds[0] == 'a' || fds[0] == 'A' {
		integralpart = formatInteger(parts[0], fds[0])
	} else if fds[0] == 'c' || fds[0] == 'C' {
		integralpart = formatInteger(parts[0], fds[0])
	} else if fds[0] == 'd' || fds[0] == 'D' {
		integralpart = parts[0]
	} else {
		integralpart = parts[0]
	}
	
	if len(parts) > 1 {
		decimalpart = formatDecimal(parts[1], fds[1])
		famount = integralpart + decimalpart
	} else {
		famount = integralpart
	}
	return fmt.Sprintf("%s", famount) // Format float64 with 2 decimal places and comma separators
}

func main() {

	var templateFile string
	var jsonFile string
	var outFile string
	// os.Args contains the command-line arguments.
	// os.Args[0] is the program name.
	// os.Args[1:] are the actual arguments.
	args := os.Args[1:]

	if len(args) == 0 || len(args) == 1 {
		fmt.Println("Error: No arguments provided.")
		fmt.Println("Usage: ", os.Args[0], "<templateFile> <jsonFile> <outFile>")
		os.Exit(1) // Exit with a non-zero status to indicate an error
	}

	// Check if  2 out of 3 arguments are provided
	if len(args) == 2 {

		fmt.Println("  Args:", os.Args)
		fmt.Println("  In Progress...")
		templateFile = os.Args[1]
		jsonFile = os.Args[2]
		outFile = "outfile.html"
		fmt.Println("Default output file is outfile.gohtml")
	}

	// Check if  2 out of 4 arguments are provided
	if len(args) == 3 {
		fmt.Println("  Args:", os.Args)
		fmt.Println("  In Progress...")
		templateFile = os.Args[1]
		jsonFile = os.Args[2]
		outFile = os.Args[3]
	}

	testgohtmljson(templateFile, jsonFile, outFile)
}

func testgohtmljson(templateFile string, jsonFile string, outFile string) {
	// Read the HTML file
	jsonData, err := os.ReadFile(jsonFile)
	if err != nil {
		fmt.Printf("Error reading JSON file: %v\n", err)
		return
	}

	// Parse JSON into a map
	var data map[string]interface{}
	err = json.Unmarshal(jsonData, &data)
	if err != nil {
		log.Fatalf("Error parsing JSON: %v", err)
	}

	// Parse and execute template
	funcMap := createFuncMap()
	tmpl, err := template.New(templateFile).Funcs(funcMap).ParseFiles(templateFile)
	if err != nil {
		log.Fatalf("Error loading template: %v", err)
	}

	// Render template to standard output or file
	outputFile, err := os.Create(outFile)
	if err != nil {
		log.Fatalf("Error creating output file: %v", err)
	}
	defer outputFile.Close()

	err = tmpl.Execute(outputFile, data)
	if err != nil {
		log.Fatalf("Error executing template: %v", err)
	}
}

// Custom template functions
func createFuncMap() template.FuncMap {
	return template.FuncMap{
		"formatNumber": formatNumber,
	}
}
